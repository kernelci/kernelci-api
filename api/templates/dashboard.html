<!DOCTYPE html>
<html>
<head>
    <title>Maestro Mini-dashboard</title>
    <!-- add vertical divider at menu -->
    <style>
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-size: 14px;
            line-height: 20px;
            color: #333333;
            background-color: #ffffff;
            padding: 10px;
        }
        #menu {
            background-color: #f5f5f5;
            border-bottom: 1px solid #e5e5e5;
            border-top: 1px solid #e5e5e5;
            margin-bottom: 20px;
            padding: 10px 0;
        }
        #menu a {
            color: #999999;
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
            text-decoration: none;
            /* Add light grey box for each menu item */
            padding: 10px;
            border: 1px solid #e5e5e5;
            border-radius: 4px;

        }
        #menu a:hover {
            color: #333333;
            text-decoration: none;            
        }
        #menu a:active {
            color: #333333;
            text-decoration: none;
        }
        #menu a:focus {
            color: #333333;
            text-decoration: none;
        }
        /* Add selectbox at right side of div */
        #menu select {
            float: right;
        }
        #menu option {
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
            text-decoration: none;
        }
        #menu label {
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
            text-decoration: none;
            float: right;
        }
        #requestinfo {
            background-color: #f5f5f5;
            border-bottom: 1px solid #e5e5e5;
            border-top: 1px solid #e5e5e5;
            margin-bottom: 20px;
            padding: 10px 0;
        }
        #requestinfo input {
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
            text-decoration: none;
        }
        #requestinfo button {
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
            text-decoration: none;
        }
        #miscbuttons {
            background-color: #f5f5f5;
            border-bottom: 1px solid #e5e5e5;
            border-top: 1px solid #e5e5e5;
            margin-bottom: 20px;
            padding: 10px 0;
        }
        #miscbuttons button {
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
            text-decoration: none;
        }
        .results {
            border-collapse: collapse;
            border-spacing: 1;
            width: 100%;
            border: 1px solid #ddd;
            /* shadow */
            box-shadow: 5px 5px 5px #888888;

        }
        .results th, .results td {
            text-align: left;
            padding: 8px;
        }
        /* alternate color for rows, depends on tr class, fail - pink, null - yellow */
        .results tr:nth-child(even){background-color: #f2f2f2}
        .results tr:hover {background-color: #ddd;}
        .results tr.fail {background-color: lightpink}
        .results tr.pass {background-color: lightgreen}
        .results tr.null {background-color: #ffffcc}
        /* slowly glowing */
        @keyframes glowing {
            0% { background-color: lightcyan; }
            50% { background-color: lightblue; }
            100% { background-color: lightcyan; }
        }
        .results tr.building {
            background-color: lightcyan;
            animation: glowing 1500ms infinite;
            animation-name: glowing;
        }
        .results th {
            background-color: #4CAF50;
            color: white;
        }
        /* highlight node id as link, as its clickable */
        .tdnodeid {
            color: blue;
            text-decoration: underline;
            cursor: pointer;
        }
        #nodeinfo {
            line-height: 20px; /* Fixed line height */
            white-space: pre-wrap; /* To wrap text and preserve spaces and line breaks */
        }
        /* a bit more fancy selectbox */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding: 2px 30px 2px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            background-image: url('data:image/svg+xml;utf8,<svg fill="black" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position: 100% 50%;
        }
        /* highlight commit as link */
        .commitall {
            color: blue;
            text-decoration: underline;
            cursor: pointer;
        }
        /* highlight showtests as link */
        .showtests {
            color: blue;
            text-decoration: underline;
            cursor: pointer;
        }
        /* style for popup that float on top of the page, in the middle, covering rest of content */
        #popup {
            position: fixed;
            background-color: #f5f5f5;
            border: 1px solid #e5e5e5;
            padding: 10px;
            display: none;
            z-index: 1000;
            align-items: center;
            justify-content: center;
            /* center */
            top: 50%;
            left: 50%;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.2.1/themes/default/style.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jstree/3.2.1/jstree.min.js"></script>
    <script>
        var pagebaseurl;
        var apiurl;
        var mainmenu = [
            {
                "name": "Home",
                "suffix": "",
            },
            {
                "name": "Builds",
                "suffix": "?builds",
            },
            {
                "name": "Test suites",
                "suffix": "?testsuites",
            },
            {
                "name": "All tests",
                "suffix": "?tests",
            },
        ];
        var nodes = {}
        var nodes_current_filter = "";
        var nodes_startdate = "";
        var nodes_update_in_progress = false;
        var display_parameters = "";
        var jstree_state = false;
        var NODES_LIMIT = 5000;

    /*
    As a syntactic convenience, if the operator matches one of >, <, >=, <=, !=
    then the corresponding API operator '__gt', '__lt', '__gte', '__lte',
    '__ne' is added to the key name automatically.  Spaces can also be used
    around the operators, although this typically means adding double quotes on
    the command line around each attribute.  As such, the example used
    previously is equivalent to "score >= 100".
    """
    operators = {
        '>': '__gt',
        '<': '__lt',
        '>=': '__gte',
        '<=': '__lte',
        '!=': '__ne',
        '=': '',
    }
        // on python we split by using regex
            pattern = re.compile(r'^([.a-zA-Z0-9_-]+) *([<>!=]+) *(.*)')
        */
        function convert_condition(condition) {
            var operators = {
                '>': '__gt=',
                '<': '__lt=',
                '>=': '__gte=',
                '<=': '__lte=',
                '!=': '__ne=',
                '=': '=',
            }
            //var pattern = /^([.a-zA-Z0-9_-]+) *([<>!=]+) *(.*)/;
            var pattern = /^([.a-zA-Z0-9_-]+)([<>!=]+)(.*)/;
            var match = pattern.exec(condition);
            if (match == null) {
                console.log("condition: " + condition + " does not match");
                return condition;
            }
            var key = match[1];
            var op = match[2];
            var value = match[3];
            if (op in operators) {
                op = operators[op];
            }
            console.log("key: " + key + " op: " + op + " value: " + value);
            return key + op + value;
        }

        function humanAge(diff) {
            var diffString = "";
            var diffhours = Math.floor(diff / (1000 * 60 * 60)) % 24;
            var diffminutes = Math.floor(diff / (1000 * 60)) % 60;
            if (diffhours > 0) {
                diffString += diffhours + "h ";
            }
            diffString += diffminutes + "m";

            return diffString;
        }

        function updresdiv(html) {
            var resdiv = document.getElementById("results");
            if (jstree_state) {
                $('#results').jstree().destroy(true);
                jstree_state = false;
            }
            resdiv.innerHTML = html;
        }

        function getnodes(url) {
            var request = new XMLHttpRequest();
            nodes_update_in_progress = true;
            request.open('GET', url, true);
            request.onload = function() {
                if (request.status >= 200 && request.status < 400) {
                    var data = JSON.parse(request.responseText);
                    if (data.items == undefined) {
                        console.log("getnodes() no items");
                        return;
                    }
                    if (data.items.length > NODES_LIMIT) {
                            console.log("getnodes() too many items: " + data.items.length);
                            return;
                    }

                    if (data.offset == 0) {
                        nodes = data;
                        console.log("getnodes() first page: " + nodes.items.length + "Total " + data.total);
                        /*
                        // this will knock down the server
                        // submit also queries to fetch other pages
                        chunks = Math.ceil(data.total / NODES_LIMIT);
                        for (var i = 1; i < chunks; i++) {
                            var requrl = url.split("&offset")[0];
                            url = requrl + "&offset=" + (i * NODES_LIMIT);
                            console.log("getnodes() next page: " + url);
                            getnodes(url);
                        }
                        */
                    } else {
                        nodes.items = nodes.items.concat(data.items);
                    }
                    if (nodes.items.length == data.total) {
                        console.log("getnodes() all nodes: " + nodes.items.length);
                        updresults();
                        displayMenu();
                        showpopup("");
                        nodes_update_in_progress = false;
                    } else {
                        current_nodes = nodes.items.length;
                        showpopup("Retrieving nodes: " + current_nodes + " of " + data.total);
                        // request next chunk
                        var requrl = url.split("&offset")[0];
                        url = requrl + "&offset=" + current_nodes;
                        console.log("getnodes() next page: " + url);
                        getnodes(url);
                    }
                    /*
                    // did we got all?
                    if (nodes.items.length < data.total) {
                        // remove offset from url if present
                        var requrl = url.split("&offset")[0];
                        url = requrl + "&offset=" + (data.offset + data.items.length);
                        console.log("getnodes() next page: " + url);
                        popup = "Retrieving nodes: " + (nodes.items.length) + " of " + data.total;
                        showpopup(popup);
                        getnodes(url);
                    } else {
                        console.log("getnodes() all nodes: " + nodes.items.length);
                        updresults();
                        displayMenu();
                        showpopup("");
                    }
                    */
                }
            };
            request.onerror = function() {
                // There was a connection error of some sort
            };
            
            request.send();
        }

        /* Here we do 2 API calls to retrieve for specified timeframe:
        1)Retrieve all kernels we built
        2)Retrieve all tests we ran
        */
        function updatenodes(conditions) {
            // request API for node info
            var url = apiurl + "/latest/nodes?";
            var urlsuffix = "";
            //var request = new XMLHttpRequest();
            console.log("display_parameters: " + display_parameters);
            // if no display_parameters, then we dont do anything
            if (display_parameters.length == 0) {
                console.log("updatenodes() no display_parameters");
                return;
            }
            var is_kbuilds = false;
            for (var i = 0; i < display_parameters.length; i++) {
                if (display_parameters[i] == "builds" || display_parameters[i].indexOf("displaycommit") != -1 || display_parameters[i].indexOf("showknode") != -1) {
                    is_kbuilds = true;
                    break;
                }
            }
            if (is_kbuilds) {
                // append to conditions kind=kbuild
                conditions.push("kind=kbuild");
            }

            // treetests - we need to fetch all nodes for specific commit
            if (display_parameters.length == 1 && display_parameters[0].indexOf("treetests") != -1) {
                // remove all other conditions
                conditions = [];
                // append to conditions kind=test
                conditions.push("data.kernel_revision.commit=" + display_parameters[0].split("=")[1]);
            }

            // build url nodes?condition1&condition2&condition3
            for (var i = 0; i < conditions.length; i++) {
                dec = decodeURIComponent(conditions[i]);
                urlsuffix += convert_condition(dec);
                if (i != conditions.length - 1) {
                    urlsuffix += "&";
                }
            }

            if (urlsuffix == nodes_current_filter && nodes.items != undefined) {
                // same as before, do nothing
                console.log("updatenodes() same filter ("+urlsuffix+"), do nothing");
                return;
            }
            nodes_current_filter = urlsuffix;
            url += urlsuffix;
            url += "&limit=" + NODES_LIMIT;
            console.log("updatenodes() url: " + url);
            getnodes(url);
            showpopup("Retrieving nodes...");
        }

        function updtimeframe() {
            var timeframe = document.getElementById("timeframe").value;
            var conditions = [];
            var now = new Date();
            var weekago = new Date(now.getTime() - (timeframe * 60 * 60 * 1000));
            console.log("timeframe: last " + timeframe + " hours");
            // update url with new timeframe
            // search=created>2024-03-18T06:12:32
            startdate = weekago.toISOString().split(".")[0];
            nodes_startdate = startdate;
            conditions = ["created>" + startdate];
            // force flush old filter to make forced refresh
            nodes_current_filter = "";
            updatenodes(conditions);
        }
        // convert nodes to sorted by date array
        function nodes_array() {
            var nodesarray = [];
            if (nodes.items == undefined) {
                return nodesarray;
            }
            for (var i = 0; i < nodes.items.length; i++) {
                var node = nodes.items[i];
                // tree, branch, commit
                //console.log("node: " + node.kind + " " + node.result + " " + node.data.kernel_revision.tree + " " + node.data.kernel_revision.branch + " " + node.data.kernel_revision.commit + " " + node.created + " " + node.result);
                nodesarray.push(node);
            }
            // print count
            console.log("nodesarray: " + nodesarray.length);
            // sort by created date
            nodesarray.sort(function(a, b) {
                return new Date(b.created) - new Date(a.created);
            });
            return nodesarray;
        }

        function setmiscbuttons(cbdata, name="Back") {
            var miscbuttons = document.getElementById("miscbuttons");
            var miscbuttonshtml = "";
            if (cbdata) {
                miscbuttonshtml += "<button onclick=\"" + cbdata + "\">" + name + "</button>";
                miscbuttons.innerHTML = miscbuttonshtml;
                // set style to display: block
                miscbuttons.style.display = "block";
            } else {
                miscbuttons.innerHTML = "";
                // set style to display: none
                miscbuttons.style.display = "none";
            }
        }

        function displaysumbuilds() {
            var resultshtml = "<table class=\"results\">";
            resultshtml += "<tr><th>Date</th><th>Tree</th><th>Branch</th><th>Commit</th><th>Describe</th><th>Builds</th><th>Pass</th><th>Fail</th><th>Incomplete</th><th>Remark</th></tr>";
            var nodesarray = nodes_array();
            var builds = {};
            // Set misc button as refresh
            setmiscbuttons("updtimeframe()", "Refresh");
            // set url to ?builds
            var url = pagebaseurl + "?builds";
            window.history.pushState("", "", url);

            // first we make a list of all commits and statistics of builds for each
            for (var i = 0; i < nodesarray.length; i++) {
                var node = Object.assign({}, nodesarray[i]);
                // reduce node.created to just date+time
                node.created = node.created.split("T")[0] + " " + node.created.split("T")[1].split(".")[0];
                if (node.kind == "kbuild") {
                    // if tree or treebranch set to any value, use them as filter too
                    if (document.getElementById("tree") != null) {
                        tree_filter = document.getElementById("tree").value;
                    } else {
                        tree_filter = "";
                    }
                    if (document.getElementById("treebranch") != null) {
                        treebranch_filter = document.getElementById("treebranch").value;
                    } else {
                        treebranch_filter = "";
                    }
                    if (tree_filter != "") {
                        if (node.data.kernel_revision.tree != tree_filter) {
                            continue;
                        }
                    }
                    if (treebranch_filter != "") {
                        var treebranch = node.data.kernel_revision.tree + "/" + node.data.kernel_revision.branch;
                        if (treebranch != treebranch_filter) {
                            continue;
                        }
                    }

                    var key = node.data.kernel_revision.tree + " " + node.data.kernel_revision.branch + " " + node.data.kernel_revision.commit;
                    if (key in builds) {
                        builds[key].builds += 1;
                        if (node.result == "pass") {
                            builds[key].pass += 1;
                        } else if (node.result == "fail") {
                            builds[key].fail += 1;
                        } else if (node.result == "incomplete") {
                            builds[key].incomplete += 1;
                        } else {
                            builds[key].unknown += 1;
                        }
                    } else {
                        builds[key] = {};
                        // add tree, branch, commit
                        builds[key].tree = node.data.kernel_revision.tree;
                        builds[key].branch = node.data.kernel_revision.branch;
                        builds[key].commit = node.data.kernel_revision.commit;
                        builds[key].describe = node.data.kernel_revision.describe;
                        builds[key].created = node.created;
                        builds[key].builds = 1;
                        builds[key].pass = 0;
                        builds[key].fail = 0;
                        builds[key].incomplete = 0;
                        builds[key].unknown = 0;
                        if (node.result == "pass") {
                            builds[key].pass += 1;
                        } else if (node.result == "fail") {
                            builds[key].fail += 1;
                        } else if (node.result == "incomplete") {
                            builds[key].incomplete += 1;
                        } else {
                            builds[key].unknown += 1;
                        }
                    }
                }
            }
            // now we display the list: tree, branch, commit, builds, pass, fail
            for (var key in builds) {
                // if we have unknown, likely it means build in progress, then mark it as class="building"
                if (builds[key].unknown > 0) {
                    tr_class = "building";
                } else {
                    tr_class = "";
                }
                resultshtml += "<tr class=\"" + tr_class + "\">";
                resultshtml += "<td>" + builds[key].created + "</td>";
                resultshtml += "<td>" + builds[key].tree + "</td>";
                resultshtml += "<td>" + builds[key].branch + "</td>";
                resultshtml += "<td class=\"commitall\">" + builds[key].commit + "</td>";
                resultshtml += "<td>" + builds[key].describe + "</td>";
                resultshtml += "<td>" + builds[key].builds + "</td>";
                resultshtml += "<td>" + builds[key].pass + "</td>";
                resultshtml += "<td>" + builds[key].fail + "</td>";
                resultshtml += "<td>" + builds[key].incomplete + "</td>";
                if (builds[key].unknown > 0) {
                    resultshtml += "<td>Building...</td>";
                } else {
                    resultshtml += "<td class=\"showtests\">Show tests</td>";
                }
                resultshtml += "</tr>";
            }
            resultshtml += "</table>";
            updresdiv(resultshtml);
            // add onclick of commitall class - display all builds for this commit displayallbuilds(commit)
            var commitall = document.getElementsByClassName("commitall");
            for (var i = 0; i < commitall.length; i++) {
                commitall[i].addEventListener("click", function(event) {
                    event.preventDefault();
                    var commit = this.innerHTML;
                    displayallbuilds(commit);
                });
            }
            // add onclick of showtests class - display all builds for this commit displayallbuilds(commit)
            var showtests = document.getElementsByClassName("showtests");
            for (var i = 0; i < showtests.length; i++) {
                showtests[i].addEventListener("click", function(event) {
                    event.preventDefault();
                    // clear all nodes
                    nodes = {};
                    var commit = this.parentElement.children[3].innerHTML;
                    showtreetests(commit);
                });
            }
        }

        // Display summary of all builds
        function displayallbuilds(commit) {
            setmiscbuttons("displaysumbuilds()");
            // set url to ?displaycommit=commit
            var url = pagebaseurl + "?displaycommit=" + commit;
            window.history.pushState("", "", url);            

            // header: kernel, tree, branch, config, result, datetime
            var resultshtml = "<table class=\"results\">";
            resultshtml += "<tr><th>Build</th><th>Date</th><th>Tree</th><th>Branch</th><th>Arch</th><th>Compiler</th><th>Config</th><th>Commit</th><th>Result</th></tr>";
            var nodesarray = nodes_array();
            console.log("nodesarray: " + nodesarray.length);
            for (var i = 0; i < nodesarray.length; i++) {
                // make copy of node
                var node = Object.assign({}, nodesarray[i]);
                // reduce node.created to just date+time
                node.created = node.created.split("T")[0] + " " + node.created.split("T")[1].split(".")[0];
                // if commit set - use as filter
                if (commit != undefined) {
                    // check if node have data and kernel_revision and commit HACK HACK TODO FIXME
                    if (node.data == undefined || node.data.kernel_revision == undefined || node.data.kernel_revision.commit == undefined) {
                        continue;
                    }
                    if (node.data.kernel_revision.commit != commit) {
                        continue;
                    }
                }
                //console.log("node: " + node.kind + " " + node.result + " " + node.data.kernel_revision.tree + " " + node.data.kernel_revision.branch + " " + node.data.kernel_revision.commit + " " + node.created + " " + node.result);
                if (node.kind == "kbuild") {
                    // set class depends on node.result
                    tr_class = node.result;
                    resultshtml += "<tr class=\"" + tr_class + "\">";

                    resultshtml += "<td onclick=\"showknode('" + node.id + "')\" class=\"tdnodeid\">" + node.id + "</td>";
                    resultshtml += "<td>" + node.created + "</td>";
                    resultshtml += "<td>" + node.data.kernel_revision.tree + "</td>";
                    resultshtml += "<td>" + node.data.kernel_revision.branch + "</td>";
                    resultshtml += "<td>" + node.data.arch + "</td>";
                    resultshtml += "<td>" + node.data.compiler + "</td>";
                    if (node.data.config_full == "") {
                        resultshtml += "<td>Unknown</td>";
                    } else {
                        resultshtml += "<td>" + node.data.config_full + "</td>";
                    }
                    resultshtml += "<td>" + node.data.kernel_revision.commit + "</td>";
                    if (node.result == "pass") {
                        resultshtml += "<td>" + node.result + "</td>";
                    } else {
                        resultshtml += "<td class=\"" + node.result + "\">" + node.result + "</td>";
                    }
                    resultshtml += "</tr>";
                }
            }
            resultshtml += "</table>";
            updresdiv(resultshtml);
        }

        function showknode(nodeid) {
            var found_node = false;
            console.log("show nodeid: " + nodeid);
            // set url showknode=XXXXX
            var url = pagebaseurl + "?showknode=" + nodeid;
            window.history.pushState("", "", url);

            // check if nodes.items exist
            if (nodes.items == undefined) {
                nodeinfohtml = "<tr><td>Error</td><td>No nodes found</td><td></td></tr>";
                updresdiv(nodeinfohtml);
                return;
            }         
            // find node in nodes
            for (var i = 0; i < nodes.items.length; i++) {
                if (nodes.items[i].id == nodeid) {
                    var node = nodes.items[i];
                    var nodeinfohtml = "<tr><th>Parameter</th><th>Value</th><th>Misc</th></tr>";

                    found_node = node;
                    // is kind == kbuild ? if not - show error in results and quit
                    if (node.kind != "kbuild") {
                        nodeinfohtml += "<tr><td>Error</td><td>Node is not kbuild</td><td></td></tr>";
                        updresdiv("<table class=\"results\">" + nodeinfohtml + "</table>");
                        return;
                    }
                    for (var key in node) {
                        if (key == "data") {
                            for (var key2 in node[key]) {
                                if (key2 == "kernel_revision") {
                                    data = node[key][key2];
                                    nodeinfohtml += "<tr><td>Tree</td><td>" + data.tree + "</td><td></td></tr>";
                                    nodeinfohtml += "<tr><td>Branch</td><td>" + data.branch + "</td><td></td></tr>";
                                    nodeinfohtml += "<tr><td>Commit</td><td>" + data.commit + "</td><td></td></tr>";
                                    nodeinfohtml += "<tr><td>URL</td><td>" + data.url + "</td><td></td></tr>";
                                    nodeinfohtml += "<tr><td>Describe</td><td>" + data.describe + "</td><td></td></tr>";
                                    nodeinfohtml += "<tr><td>Arch</td><td>" + node[key].arch + "</td><td></td></tr>";
                                    nodeinfohtml += "<tr><td>Compiler</td><td>" + node[key].compiler + "</td><td></td></tr>";
                                    nodeinfohtml += "<tr><td>Config</td><td>" + node[key].config_full + "</td><td></td></tr>";
                                } else {
                                    nodeinfohtml += "<tr><td>" + key2 + "</td><td>" + node[key][key2] + "</td><td></td></tr>";
                                }
                            }
                        } else if (key == "artifacts") {
                            for (var key2 in node[key]) {
                                url = node[key][key2];
                                filename = url.split("/").pop();
                                filename = filename.split("?")[0];
                                nodeinfohtml += "<tr><td>" + key2 + "</td><td><a href=\"" + url + "\">" + filename + "</a></td><td></td></tr>";
                            }
                        } else {
                            nodeinfohtml += "<tr><td>" + key + "</td><td>" + node[key] + "</td><td></td></tr>";
                        }
                    }
                    updresdiv("<table class=\"results\">" + nodeinfohtml + "</table>");
                }
            }
            if (found_node) {
                setmiscbuttons("displayallbuilds('" + found_node.data.kernel_revision.commit + "')");
            }
        }

        function getchildren(parentnodeid) {
            var newchildren = [];
            for (var i = 0; i < nodes.items.length; i++) {
                var node = nodes.items[i];
                if (node.parent == parentnodeid) {
                    mininode = {};
                    mininode["id"] = node.id;
                    mininode["text"] = { name: node.name };
                    mininode["children"] = [];
                    newchildren.push(mininode);
                }
            }
            // recurse over new children, if they have children
            for (var i = 0; i < newchildren.length; i++) {
                newchildren[i]["children"] = getchildren(newchildren[i]["id"]);
            }
            return newchildren;
        }

        function showtreetests(commit) {
            console.log("showtreetests() commit: " + commit);
            // update url to ?showtreetests=commit
            var url = pagebaseurl + "?treetests=" + commit;
            window.history.pushState("", "", url);
            display_parameters = ["treetests=" + commit];
            
            // We need all nodes, if not present, then fetch them
            // after that we will automatically retry them
            conditions = [];
            conditions.push('data.kernel_revision.commit=' + commit);
            updatenodes(conditions);
            if (nodes.items == undefined) {
                console.log("showtreetests() no nodes");
                return;
            }
            console.log("showtreetests() nodes: " + nodes.items.length + " commit: " + commit);
            
            jstreedata = [];
            for (var i = 0; i < nodes.items.length; i++) {
                var node = nodes.items[i];
                if (node.data.kernel_revision.commit == commit) {
                    mininode = {};
                    mininode["id"] = node.id;
                    // if kind checkout - set parent as # as its root
                    if (node.kind == "checkout") {
                        mininode["parent"] = "#";
                    } else {
                        mininode["parent"] = node.parent;
                    }
                    if (node.kind == "test" && node.data.platform != undefined) {
                        mininode["text"] = "(" + node.data.platform + ") " + node.name;
                    } else if (node.kind == "checkout") {
                        mininode["text"] = node.data.kernel_revision.tree + " / " + node.data.kernel_revision.branch + " / " + node.data.kernel_revision.describe;
                    } else {
                        mininode["text"] = node.name;
                    }
                    if (node.result == "pass") {
                        mininode["icon"] = "/icons/ok.png";
                    } else if (node.result == "fail") {
                        mininode["icon"] = "/icons/bad.png";
                    } else if (node.result == "incomplete") {
                        mininode["icon"] = "/icons/warning.png";
                    }
                    mininode["a_attr"] = { href: "/viewer?node_id=" + node.id, title: "Test tooltip" };
                    jstreedata.push(mininode);
                }
            }
            console.log("showtreetests() jstreedata.length: " + jstreedata.length);
            updresdiv("");
            jstree_state = true;
            $('#results').jstree({
                'core': {
                    'data': jstreedata
                }
            });
        }

        function updresults(hint) {
            // if hint is set and == treebranch
            if (hint == "treebranch") {
                // then set select #tree to ""
                document.getElementById("tree").value = "";                
            }
            if (hint == "tree") {
                // then set select #treebranch to ""
                document.getElementById("treebranch").value = "";                
            }
            // iterate over display_parameters
            for (var i = 0; i < display_parameters.length; i++) {
                // truncate # at end
                if (display_parameters[i].indexOf("#") != -1) {
                    display_parameters[i] = display_parameters[i].split("#")[0];
                }

                // if just "builds"
                if (display_parameters[i] == "builds") {
                    displaysumbuilds();
                    return;
                }
                // Show tree of tests for specific commit
                if (display_parameters[i].indexOf("treetests=") != -1) {
                    var commit = display_parameters[i].split("=")[1];
                    showtreetests(commit);
                    return;
                }
                // if displaycommit=XXXXX, then display all builds for this commit
                if (display_parameters[i].indexOf("displaycommit=") != -1) {
                    var commit = display_parameters[i].split("=")[1];
                    displayallbuilds(commit);
                    return;
                }
                // showknode=XXXXX
                if (display_parameters[i].indexOf("showknode=") != -1) {
                    var nodeid = display_parameters[i].split("=")[1];
                    showknode(nodeid);
                    return;
                }
            }
        }

        function kernels_array() {
            // iterate over nodes and return array of kernels
            var kernels = [];
            if (nodes.items == undefined) {
                return kernels;
            }
            for (var i = 0; i < nodes.items.length; i++) {
                var node = nodes.items[i];
                if (node.kind == "kbuild") {
                    var obj = {};
                    obj["tree"] = node.data.kernel_revision.tree;
                    obj["branch"] = node.data.kernel_revision.branch;
                    // check if we already have this tree/branch in kernels array
                    var found = false;
                    for (var j = 0; j < kernels.length; j++) {
                        if (kernels[j].tree == obj.tree && kernels[j].branch == obj.branch) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        kernels.push(obj);
                    }
                }
            }
            return kernels;
        }

        function displayMenu() {
            var menu = document.getElementById("menu");
            var menuhtml = "";
            var ago = [24, 168, 720];
            var ago_desc = ["Last 24h", "Last 7d", "Last 30d"];

            // retrieve current values of timeframe
            var tf_elem = document.getElementById("timeframe");
            if (tf_elem != null) {
                var selected_timeframe = tf_elem.value;
            } else {
                var selected_timeframe = "";
            }

            for (var i = 0; i < mainmenu.length; i++) {
                menuhtml += "<a class=\"menulink\" href=\"" + mainmenu[i].suffix + "\">" + mainmenu[i].name + "</a> ";
            }
            kernels = kernels_array();
            if (kernels.length > 0) {
                var trees = [];
                var treebranch = [];

                // add all trees
                for (var i = 0; i < kernels.length; i++) {
                    if (trees.indexOf(kernels[i].tree) == -1) {
                        trees.push(kernels[i].tree);
                    }
                }
                // add all combinations of tree/branch
                for (var i = 0; i < kernels.length; i++) {
                    var current_treebranch = kernels[i].tree + "/" + kernels[i].branch;
                    if (treebranch.indexOf(current_treebranch) == -1) {
                        treebranch.push(current_treebranch);
                    }
                }
                menuhtml += "<select id=\"treebranch\" onchange=\"updresults('treebranch')\">";
                menuhtml += "<option value=\"\">Any tree/branch</option>";
                for (var i = 0; i < treebranch.length; i++) {
                    menuhtml += "<option value=\"" + treebranch[i] + "\">" + treebranch[i] + "</option>";
                }
                menuhtml += "</select>";

                menuhtml += "<select id=\"tree\" onchange=\"updresults('tree')\">";
                menuhtml += "<option value=\"\">Any tree</option>";
                for (var i = 0; i < trees.length; i++) {
                    menuhtml += "<option value=\"" + trees[i] + "\">" + trees[i] + "</option>";
                }
                menuhtml += "</select>";
            }
            // add selectbox for last 24h, 7d, 30d
            menuhtml += "<select id=\"timeframe\" onchange=\"updtimeframe()\">";
            menuhtml += "<option value=\"\">Select timeframe</option>";
            for (var i = 0; i < ago.length; i++) {
                // if selected_timeframe is equal to ago[i] then add selected attribute
                if (selected_timeframe == ago[i]) {
                    menuhtml += "<option value=\"" + ago[i] + "\" selected>" + ago_desc[i] + "</option>";
                } else {
                    menuhtml += "<option value=\"" + ago[i] + "\">" + ago_desc[i] + "</option>";
                }
            }
            menuhtml += "</select>";
            menu.innerHTML = menuhtml;
            // add event listener to all menu links (by class)
            links = document.getElementsByClassName("menulink");
            for (var i = 0; i < links.length; i++) {
                links[i].addEventListener("click", function(event) {
                    event.preventDefault();
                    var fullurl = pagebaseurl + this.getAttribute("href");
                    window.history.pushState("", "", fullurl);
                    parseParameters(fullurl);
                });
            };
        }

        function cleardivs() {
            updresdiv("");
        }

        function parseParameters(url) {
            // parse the url and extract the parameters
            var url = url.split("?")[1];
            if (url == undefined) {
                display_parameters = [];
                console.log("parseParameters clear");
                cleardivs();
                return;
            }
            display_parameters = url.split("&");
            console.log("parseParameters url: " + url);
            // alert on testsuites, tests - not ready
            if (url == "testsuites" || url == "tests") {
                alert("Not ready yet");
                display_parameters = [];
                return;
            }
            updresults();
        }

        function showpopup(text) {
            var popup = document.getElementById("popup");
            // if empty - hide
            if (text == "") {
                popup.innerHTML = "Completed";
                // close with delay 1 sec
                setTimeout(function() {
                    popup.innerHTML = text;
                    popup.style.display = "none";
                }, 1000);
            } else {
                popup.innerHTML = text;
                popup.style.display = "block";
            }
        }
    
        function onLoad() {
            // do we have a node id in the url?
            var url = window.location.href;
            pagebaseurl = url.split("?")[0];
            // api url is just remove /viewer
            apiurl = pagebaseurl.replace("/dashboard", "");
            // do we have any parameters? then call parseParameters()
            if (url.indexOf("?") != -1) {
                parseParameters(url);
            }
            displayMenu();
            // blink timeframe selectbox 5 times to attract attention
            var timeframe = document.getElementById("timeframe");
            if (timeframe != null) {
                var blink = 5;
                var blinkInterval = setInterval(function() {
                    if (blink == 0) {
                        clearInterval(blinkInterval);
                        // set to 24h
                        timeframe.value = 24;
                        if (nodes_update_in_progress == false) {
                            updtimeframe();
                        } else {
                            console.log("Already updating nodes");
                        }
                    }
                    if (timeframe.style.backgroundColor == "pink") {
                        timeframe.style.backgroundColor = "white";
                    } else {
                        timeframe.style.backgroundColor = "pink";
                    }
                    blink--;
                }, 200);
            }
        }
    </script>
</head>
<body onload="onLoad()">
<!-- nice horizontal menu at top -->
<div id="menu">
</div>
<div id="miscbuttons"></div>
<div id="results"></div>
<div id="tree"></div>
<div id="popup"></div>
</body>
</html>
