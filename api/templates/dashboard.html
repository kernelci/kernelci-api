<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>KernelCI Dashboard</title>
    <style>
        :root {
            --bg-start: #0f172a;
            --bg-end: #111827;
            --panel: rgba(17, 24, 39, 0.88);
            --panel-border: rgba(148, 163, 184, 0.25);
            --text: #e2e8f0;
            --subtext: #94a3b8;
            --accent: #8b5cf6;
            --pass: #16a34a;
            --pass-soft: rgba(22, 163, 74, 0.24);
            --fail: #dc2626;
            --fail-soft: rgba(220, 38, 38, 0.28);
            --infra: #6b7280;
            --infra-soft: rgba(107, 114, 128, 0.28);
            --ok: #34d399;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            color: var(--text);
            font-family: "Montserrat", "Segoe UI", "Trebuchet MS", sans-serif;
            background:
                radial-gradient(circle at 10% 0%, rgba(139, 92, 246, 0.28), transparent 35%),
                radial-gradient(circle at 90% 25%, rgba(16, 185, 129, 0.18), transparent 30%),
                linear-gradient(140deg, var(--bg-start), var(--bg-end));
            min-height: 100vh;
        }

        .dashboard {
            max-width: 100%;
            margin: 0;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .topbar {
            display: flex;
            flex-wrap: wrap;
            gap: 14px;
            align-items: center;
            justify-content: space-between;
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 10px 18px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(4px);
        }

        .brand {
            font-family: "Poppins", "Montserrat", "Trebuchet MS", sans-serif;
            font-size: 1.25rem;
            font-weight: 700;
            letter-spacing: 0.25px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brand:before {
            content: "";
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6, #22d3ee);
        }

        .menu {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .menu a {
            color: var(--subtext);
            text-decoration: none;
            font-weight: 600;
            font-size: 0.95rem;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid transparent;
            transition: all 0.25s;
        }

        .menu a.active,
        .menu a:hover {
            color: var(--text);
            border-color: rgba(148, 163, 184, 0.45);
            background: rgba(99, 102, 241, 0.16);
        }

        .menu a:focus-visible {
            outline: 2px solid rgba(56, 189, 248, 0.7);
            outline-offset: 2px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .toolbar {
            display: grid;
            grid-template-columns: repeat(4, minmax(140px, 1fr));
            gap: 10px;
            align-items: end;
        }

        .control {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }

        .control label {
            color: var(--subtext);
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.2px;
            text-transform: uppercase;
        }

        select,
        button {
            width: 100%;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(2, 6, 23, 0.65);
            color: var(--text);
            padding: 10px 12px;
            font-size: 0.92rem;
            font-weight: 600;
        }

        button {
            cursor: pointer;
            background: linear-gradient(135deg, #8b5cf6, #06b6d4);
            border: none;
        }

        select:focus-visible,
        button:focus-visible {
            outline: 2px solid rgba(56, 189, 248, 0.7);
            outline-offset: 2px;
        }

        .status-bar {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            color: var(--subtext);
            font-size: 0.9rem;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(148, 163, 184, 0.28);
            padding: 6px 10px;
            border-radius: 999px;
            margin-bottom: 6px;
        }

        .badge.pass { border-color: rgba(16, 185, 129, 0.5); color: #a7f3d0; }
        .badge.fail { border-color: rgba(239, 68, 68, 0.6); color: #fecaca; }
        .badge.infra { border-color: rgba(148, 163, 184, 0.6); color: #cbd5e1; }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .legend span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: var(--text);
            font-size: 0.82rem;
        }

        .legend .swatch {
            width: 12px;
            height: 12px;
            border-radius: 999px;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .legend .pass { background: var(--pass); }
        .legend .fail { background: var(--fail); }
        .legend .infra { background: var(--infra); }

        .content-head {
            margin: 8px 0 12px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: baseline;
        }

        .content-head h1 {
            margin: 0;
            font-size: 1.25rem;
            letter-spacing: 0.4px;
        }

        .hint {
            color: var(--subtext);
            font-size: 0.92rem;
        }

        .heatmap-shell {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            max-height: 75vh;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        th,
        td {
            text-align: left;
            border-bottom: 1px solid rgba(148, 163, 184, 0.12);
            padding: 6px 8px;
            font-size: 0.8rem;
            white-space: nowrap;
            color: var(--text);
            overflow: hidden;
            text-overflow: ellipsis;
        }

        thead th {
            position: sticky;
            top: 0;
            background: rgba(30, 41, 59, 0.98);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: #cbd5e1;
            z-index: 2;
        }

        thead th.vertical {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            height: 160px;
            padding: 10px 2px;
            text-align: left;
            vertical-align: middle;
        }

        tbody tr:hover {
            background: rgba(148, 163, 184, 0.1);
        }

        .col-header-id {
            width: 110px;
        }

        .col-header-ts {
            width: 160px;
        }

        .cell {
            padding: 4px;
            width: 28px;
            min-width: 28px;
            max-width: 28px;
            text-align: center;
        }

        .square {
            display: block;
            width: 18px;
            height: 18px;
            margin: 0 auto;
            border-radius: 3px;
            transition: transform 0.1s ease;
            text-decoration: none;
        }

        .square.pass { background: var(--pass); box-shadow: 0 0 4px var(--pass-soft); }
        .square.fail { background: var(--fail); box-shadow: 0 0 4px var(--fail-soft); }
        .square.infra { background: var(--infra); box-shadow: 0 0 4px var(--infra-soft); }
        .square.unknown { background: #374151; }

        .square:hover {
            transform: scale(1.4);
            z-index: 5;
            position: relative;
        }

        .status-text {
            font-weight: 600;
            font-size: 0.75rem;
            color: var(--subtext);
            margin-bottom: 8px;
        }

        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid rgba(226, 232, 240, 0.25);
            border-top-color: #8b5cf6;
            animation: spin 0.9s linear infinite;
        }

        .empty,
        .error {
            color: var(--subtext);
            border: 1px dashed rgba(148, 163, 184, 0.35);
            border-radius: 12px;
            padding: 18px;
        }

        .home-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .home-card {
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 14px;
            background: linear-gradient(160deg, rgba(148, 163, 184, 0.14), rgba(14, 165, 233, 0.06));
        }

        .home-card h3 {
            margin: 0 0 4px;
            font-size: 0.95rem;
            color: #f1f5f9;
        }

        .home-card p {
            margin: 0;
            color: var(--subtext);
            line-height: 1.4;
            font-size: 0.86rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 900px) {
            .dashboard {
                padding: 12px;
            }

            .toolbar {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .topbar {
                gap: 10px;
            }
        }

        @media (max-width: 540px) {
            .toolbar {
                grid-template-columns: minmax(0, 1fr);
            }

            .menu {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <main class="dashboard">
        <header class="topbar">
            <div class="brand">KernelCI Dashboard</div>
            <nav class="menu" id="menu"></nav>
        </header>

        <section class="panel" id="toolbarPanel"></section>

        <section class="panel">
            <div class="status-bar" id="status"></div>
            <div id="legend"></div>
            <div class="content-head">
                <h1 id="viewTitle">Dashboard</h1>
                <div id="viewHint" class="hint"></div>
            </div>
            <div id="content"></div>
        </section>
    </main>

    <script>
        const MENU_ITEMS = [
            {name: 'Home', suffix: ''},
            {name: 'Builds', suffix: 'builds'},
            {name: 'Test suites', suffix: 'testsuites'},
            {name: 'All tests', suffix: 'tests'},
        ];

        const TIMEFRAME_OPTIONS = [
            {value: '24h', label: 'Last 24h', hours: 24},
            {value: '7d', label: 'Last 7d', hours: 168},
            {value: '30d', label: 'Last 30d', hours: 720},
            {value: '90d', label: 'Last 90d', hours: 2160},
            {value: 'all', label: 'All data'},
        ];

        const API_BASE = `${window.location.origin}/latest`;

        const state = {
            mode: 'home',
            tree: '',
            branch: '',
            timeframe: '30d',
        };

        const statusMap = {
            pass: 'pass',
            fail: 'fail',
            incomplete: 'infra',
            building: 'infra',
            error: 'infra',
            infra: 'infra',
            infra_error: 'infra',
            aborted: 'infra',
            unknown: 'infra',
        };

        const maxRows = 80;
        const maxColumns = 24;
        const batchSize = 1000;
        const maxNodesPerRequest = 6000;

        function normalizeMode(params) {
            if (params.has('builds')) {
                return 'builds';
            }
            if (params.has('testsuites')) {
                return 'testsuites';
            }
            if (params.has('tests')) {
                return 'tests';
            }
            return 'home';
        }

        function parseState() {
            const params = new URLSearchParams(window.location.search);
            state.mode = normalizeMode(params);
            state.tree = params.get('tree') || '';
            state.branch = params.get('branch') || '';
            state.timeframe = params.get('timeframe') || '30d';
            const validTimeframes = TIMEFRAME_OPTIONS.map((item) => item.value);
            if (!validTimeframes.includes(state.timeframe)) {
                state.timeframe = '30d';
            }
            return {...state};
        }

        function timeframeDate(hoursMode) {
            if (hoursMode === 'all') {
                return '';
            }
            const hours = TIMEFRAME_OPTIONS.find((item) => item.value === hoursMode)?.hours;
            if (!hours) {
                return '';
            }
            const now = new Date();
            const pivot = new Date(now.getTime() - hours * 60 * 60 * 1000);
            return pivot.toISOString().split('.')[0];
        }

        function statusClass(rawStatus) {
            if (!rawStatus) {
                return 'unknown';
            }
            const status = String(rawStatus).toLowerCase();
            return statusMap[status] || 'unknown';
        }

        function statusLabel(rawStatus) {
            if (!rawStatus) {
                return 'N/A';
            }
            const status = String(rawStatus).toLowerCase();
            if (statusMap[status] === 'pass') {
                return 'PASS';
            }
            if (statusMap[status] === 'fail') {
                return 'FAIL';
            }
            return 'INFRA';
        }

        function getKernelRevision(node) {
            const revision = node?.data?.kernel_revision || {};
            return {
                tree: revision.tree || 'unknown',
                branch: revision.branch || 'unknown',
                commit: revision.commit || 'unknown',
                describe: revision.describe || '',
            };
        }

        function getSuiteName(node) {
            const data = node?.data || {};
            return data.suite || data.test_suite || node.name || 'unknown';
        }

        function buildQuery(kind) {
            const params = new URLSearchParams();
            params.set('kind', kind);
            if (state.timeframe !== 'all') {
                const date = timeframeDate(state.timeframe);
                if (date) {
                    params.set('created__gt', date);
                }
            }
            if (state.tree) {
                params.set('data.kernel_revision.tree', state.tree);
            }
            if (state.branch) {
                params.set('data.kernel_revision.branch', state.branch);
            }
            return params;
        }

        async function fetchAllNodes(kind) {
            let offset = 0;
            const allNodes = [];
            const query = buildQuery(kind);

            while (allNodes.length < maxNodesPerRequest) {
                query.set('limit', String(batchSize));
                query.set('offset', String(offset));
                const resp = await fetch(`${API_BASE}/nodes/fast?${query.toString()}`);
                if (!resp.ok) {
                    const txt = await resp.text();
                    throw new Error(`Request failed (${resp.status}): ${txt}`);
                }
                const chunk = await resp.json();
                if (!Array.isArray(chunk)) {
                    throw new Error('Unexpected response from /nodes/fast');
                }
                allNodes.push(...chunk);
                if (chunk.length < batchSize) {
                    break;
                }
                offset += batchSize;
            }

            allNodes.sort((a, b) => new Date(b.created).getTime() - new Date(a.created).getTime());
            return allNodes;
        }

        function collectTreeBranch(nodes) {
            const perTree = {};
            nodes.forEach((node) => {
                const rev = getKernelRevision(node);
                if (!perTree[rev.tree]) {
                    perTree[rev.tree] = new Set();
                }
                perTree[rev.tree].add(rev.branch);
            });
            const trees = Object.keys(perTree).sort((a, b) => a.localeCompare(b));
            const branchMap = {};
            trees.forEach((tree) => {
                branchMap[tree] = Array.from(perTree[tree]).sort((a, b) => a.localeCompare(b));
            });
            return {trees, branchMap};
        }

        function updateURL() {
            const params = new URLSearchParams();

            if (state.mode !== 'home') {
                params.set(state.mode, '1');
            }
            if (state.timeframe !== '30d') {
                params.set('timeframe', state.timeframe);
            }
            if (state.tree) {
                params.set('tree', state.tree);
            }
            if (state.branch) {
                params.set('branch', state.branch);
            }

            const suffix = params.toString();
            const base = `${window.location.pathname}`;
            const fullUrl = suffix ? `${base}?${suffix}` : base;
            window.history.pushState({}, '', fullUrl);
        }

        function createSelect(id, label, options, value, onChange) {
            const control = document.createElement('div');
            control.className = 'control';

            const labelEl = document.createElement('label');
            labelEl.setAttribute('for', id);
            labelEl.textContent = label;

            const select = document.createElement('select');
            select.id = id;

            options.forEach((option) => {
                const opt = document.createElement('option');
                opt.value = option.value;
                opt.textContent = option.label;
                select.appendChild(opt);
            });

            if (value !== undefined) {
                select.value = value;
            }

            select.addEventListener('change', () => onChange(select.value));

            control.appendChild(labelEl);
            control.appendChild(select);
            return control;
        }

        function updateActiveMenu() {
            const menu = document.getElementById('menu');
            menu.innerHTML = '';

            MENU_ITEMS.forEach((entry) => {
                const link = document.createElement('a');
                const suffix = entry.suffix ? `?${entry.suffix}` : '';
                const url = `${window.location.pathname}${suffix}`;
                link.href = url;
                link.textContent = entry.name;
                if ((state.mode === 'home' && entry.suffix === '') ||
                    (state.mode === 'builds' && entry.suffix === 'builds') ||
                    (state.mode === 'testsuites' && entry.suffix === 'testsuites') ||
                    (state.mode === 'tests' && entry.suffix === 'tests')) {
                    link.classList.add('active');
                }

                link.addEventListener('click', (event) => {
                    event.preventDefault();
                    if (entry.suffix === '') {
                        state.mode = 'home';
                        state.tree = '';
                        state.branch = '';
                        state.timeframe = '30d';
                        updateURL();
                        renderDashboard();
                    } else if (entry.suffix === 'builds') {
                        event.preventDefault();
                        state.mode = 'builds';
                    } else if (entry.suffix === 'testsuites') {
                        event.preventDefault();
                        state.mode = 'testsuites';
                    } else if (entry.suffix === 'tests') {
                        event.preventDefault();
                        state.mode = 'tests';
                    }
                    if (entry.suffix) {
                        updateURL();
                        renderDashboard();
                    }
                });
                menu.appendChild(link);
            });
        }

        function renderMenuBar() {
            updateActiveMenu();
            const toolbarPanel = document.getElementById('toolbarPanel');
            const toolbar = document.createElement('div');

            if (state.mode === 'home') {
                toolbar.innerHTML = `
                    <div class="status-bar">
                        <div>Use the menu to switch modes. "Builds" for build outcomes and "Test suites" for suite progress over older/newer builds.</div>
                    </div>
                `;
                toolbarPanel.innerHTML = '';
                toolbarPanel.appendChild(toolbar);
                return;
            }

            const nodesForFilters = state.currentNodes && state.currentNodes.length
                ? state.currentNodes
                : [];
            const filterData = collectTreeBranch(nodesForFilters);
            const treeOptions = [{value: '', label: 'All trees'}];
            filterData.trees.forEach((tree) => {
                treeOptions.push({value: tree, label: tree});
            });

            const selectedTree = state.tree && treeOptions.some((item) => item.value === state.tree)
                ? state.tree
                : '';
            state.tree = selectedTree;
            if (state.tree) {
                state.branch = state.branch;
            }

            const branchChoices = [{value: '', label: 'All branches'}];
            if (state.tree && filterData.branchMap[state.tree]) {
                filterData.branchMap[state.tree].forEach((branch) => {
                    branchChoices.push({value: branch, label: branch});
                });
            } else if (!state.tree && filterData.branchMap['unknown']) {
                filterData.branchMap['unknown'].forEach((branch) => {
                    branchChoices.push({value: branch, label: branch});
                });
            }

            const timeframeChoices = TIMEFRAME_OPTIONS.map((item) => ({
                value: item.value,
                label: item.label,
            }));

            toolbar.className = 'toolbar';
            toolbar.appendChild(createSelect(
                'treeFilter',
                'Kernel tree',
                treeOptions,
                selectedTree,
                (value) => {
                    state.tree = value;
                    if (!value) {
                        state.branch = '';
                    } else if (state.branch &&
                               !filterData.branchMap[value]?.includes(state.branch)) {
                        state.branch = '';
                    }
                    updateURL();
                    renderDashboard();
                }
            ));

            toolbar.appendChild(createSelect(
                'branchFilter',
                'Branch',
                branchChoices,
                state.branch,
                (value) => {
                    state.branch = value;
                    updateURL();
                    renderDashboard();
                }
            ));

            toolbar.appendChild(createSelect(
                'timeframeFilter',
                'Time window',
                timeframeChoices,
                state.timeframe,
                (value) => {
                    state.timeframe = value;
                    updateURL();
                    renderDashboard();
                }
            ));

            const buttonWrap = document.createElement('div');
            buttonWrap.className = 'control';
            const buttonLabel = document.createElement('label');
            buttonLabel.textContent = 'Action';
            const refresh = document.createElement('button');
            refresh.textContent = 'Reload view';
            refresh.type = 'button';
            refresh.addEventListener('click', () => {
                renderDashboard();
            });
            buttonWrap.appendChild(buttonLabel);
            buttonWrap.appendChild(refresh);
            toolbar.appendChild(buttonWrap);

            toolbarPanel.innerHTML = '';
            toolbarPanel.appendChild(toolbar);
        }

        function renderLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';
            const wrap = document.createElement('div');
            wrap.className = 'legend';
            const items = [
                {name: 'PASS', clazz: 'pass'},
                {name: 'FAIL', clazz: 'fail'},
                {name: 'INFRA/other', clazz: 'infra'},
            ];
            items.forEach((item) => {
                const chip = document.createElement('span');
                chip.innerHTML = `<span class="swatch ${item.clazz}"></span>${item.name}`;
                wrap.appendChild(chip);
            });
            legend.appendChild(wrap);
        }

        function renderHome() {
            const title = document.getElementById('viewTitle');
            title.textContent = 'KernelCI Dashboard';
            const hint = document.getElementById('viewHint');
            hint.textContent = 'Use the top bar and filter controls to compare build and test status over time.';
            const content = document.getElementById('content');
            content.innerHTML = `
                <div class="home-grid">
                    <div class="home-card">
                        <h3>Builds</h3>
                        <p>Heatmap of build results per commit/configuration for a selected tree and branch.</p>
                    </div>
                    <div class="home-card">
                        <h3>Test suites</h3>
                        <p>Suite-by-suite status matrix for selected tree/branch across older and newer builds.</p>
                    </div>
                    <div class="home-card">
                        <h3>All tests</h3>
                        <p>Overall view of test states by commit and suite, useful for quick regressions.</p>
                    </div>
                </div>
            `;
        }

        function setStatus(text, extraClass = '') {
            const status = document.getElementById('status');
            status.innerHTML = '';
            const badge = document.createElement('span');
            badge.className = `badge ${extraClass}`;
            badge.textContent = text;
            status.appendChild(badge);
            if (extraClass) {
                badge.classList.remove('unknown');
            }
        }

        function setError(text) {
            const content = document.getElementById('content');
            content.innerHTML = `<div class="error">${text}</div>`;
        }

        function formatTimestamp(value) {
            if (!value) {
                return 'Unknown';
            }
            const dt = new Date(value);
            if (Number.isNaN(dt.getTime())) {
                return 'Unknown';
            }
            return dt.toISOString().replace('T', ' ').split('.')[0] + ' UTC';
        }

        function clip(value, len = 12) {
            const text = value || '';
            return text.length > len ? `${text.slice(0, len)}...` : text;
        }

        function heatCell(entry, title, rowScope) {
            if (!entry) {
                return '<td class="cell"><span class="square unknown" title="No data"></span></td>';
            }
            const result = entry.result || entry;
            const id = entry.id || null;
            const cls = statusClass(result);
            const txt = statusLabel(result);
            const tooltip = `${rowScope}\n${title}\nResult: ${txt}${id ? `\nID: ${id}` : ''}`;
            const url = id ? `/viewer?node_id=${id}` : '#';
            
            return `
                <td class="cell">
                    <a href="${url}" class="square ${cls}" title="${tooltip}"></a>
                </td>
            `;
        }

        function renderHeatGrid({rows, columns, rowKeyLabel, titleText, hintText, emptyText}) {
            if (!rows.length || !columns.length) {
                const content = document.getElementById('content');
                content.innerHTML = `<div class="empty">${emptyText}</div>`;
                return;
            }

            const safeCols = columns.slice(0, maxColumns);
            const tableBodyRows = rows.map((row) => {
                const cells = safeCols.map((col) => {
                    const entry = row.values[col];
                    const label = row.meta[col] || col;
                    return heatCell(entry, label, row.name);
                }).join('');
                
                // Shorten commit ID if it looks like one (hex string)
                let displayName = row.name;
                if (row.name.includes(' · ')) {
                    const [commit, rest] = row.name.split(' · ');
                    if (commit.length > 12) {
                        displayName = `${commit.slice(0, 8)} · ${rest}`;
                    }
                } else if (row.name.length > 20) {
                    displayName = row.name.slice(0, 12) + '...';
                }

                return `
                    <tr>
                        <td class="col-header-id" title="${row.name}">${displayName}</td>
                        <td class="col-header-ts">${formatTimestamp(row.timestamp)}</td>
                        ${cells}
                    </tr>
                `;
            }).join('');

            const headerCols = safeCols.map((col, index) => 
                `<th class="cell vertical" title="${col}">${index + 1}</th>`
            ).join('');

            const content = document.getElementById('content');
            content.innerHTML = `
                <div class="content-head">
                    <h2>${titleText}</h2>
                    <div class="status-text">${hintText}</div>
                </div>
                <div class="heatmap-shell">
                    <table>
                        <thead>
                            <tr>
                                <th class="col-header-id">${rows.length === 1 ? 'Item' : 'Commit'}</th>
                                <th class="col-header-ts">Updated</th>
                                ${headerCols}
                            </tr>
                        </thead>
                        <tbody>
                            ${tableBodyRows}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderBuilds(nodes) {
            const stateNodes = nodes.filter((node) => node.kind === 'kbuild');
            const filterData = collectTreeBranch(stateNodes);
            const grouped = new Map();
            const columnsSet = {};

            stateNodes.forEach((node) => {
                const rev = getKernelRevision(node);
                const commit = rev.commit;
                const rowKey = commit;
                const row = grouped.get(rowKey) || {
                    name: `${commit} · ${rev.tree}/${rev.branch}`,
                    timestamp: node.created,
                    values: {},
                    meta: {},
                };

                if (!grouped.has(rowKey)) {
                    grouped.set(rowKey, row);
                }

                const config = (node?.data?.config_full
                    || node?.data?.config
                    || `${node?.data?.arch || 'arch'}-${node?.data?.compiler || 'gcc'}`)
                    .trim();
                if (!row.values[config]) {
                    row.values[config] = {
                        result: node.result,
                        id: node.id
                    };
                }
                if (!columnsSet[config]) {
                    columnsSet[config] = 1;
                } else {
                    columnsSet[config] += 1;
                }
            });

            const rows = Array.from(grouped.values())
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                .slice(0, maxRows);

            const columns = Object.keys(columnsSet)
                .sort((a, b) => columnsSet[b] - columnsSet[a])
                .slice(0, maxColumns);

            renderHeatGrid({
                rows,
                columns,
                titleText: 'Build heatmap',
                hintText: 'Commit rows × build variant columns',
                emptyText: 'No builds found for the selected filters.'
            });

            setStatus(`Build nodes loaded: ${nodes.length}`, 'pass');
        }

        function renderTestSuites(nodes, aggregateByCommit = false) {
            const filterData = collectTreeBranch(nodes);
            const rows = new Map();
            const columnsSet = new Set();

            nodes
                .filter((node) => node.kind === 'test')
                .forEach((node) => {
                    const rev = getKernelRevision(node);
                    const suite = getSuiteName(node);
                    const axis = aggregateByCommit
                        ? `${suite} (${rev.tree}/${rev.branch})`
                        : rev.commit;
                    const series = aggregateByCommit
                        ? rev.commit
                        : suite;

                    if (!axis || axis === 'unknown' || !series || series === 'unknown') {
                        return;
                    }

                    columnsSet.add(series);

                    const row = rows.get(axis) || {
                        name: axis,
                        timestamp: node.created,
                        values: {},
                        meta: {},
                    };
                    if (!rows.has(axis)) {
                        rows.set(axis, row);
                    }
                    if (row.values[series] === undefined) {
                        row.values[series] = {
                            result: node.result,
                            id: node.id
                        };
                        row.meta[series] = `${rev.tree}/${rev.branch} · ${suite}`;
                    }
                });

            const columns = Array.from(columnsSet).sort();
            const sortedRows = Array.from(rows.values())
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            const limitedRows = sortedRows.slice(0, maxRows);
            return {
                rows: limitedRows,
                columns: columns,
                totalColumns: columns.length,
            };
        }

        function renderTestsuitesView(nodes) {
            const filtered = nodes.filter((node) => node.kind === 'test');
            const {rows, columns} = renderTestSuites(filtered, false);
            renderHeatGrid({
                rows,
                columns,
                titleText: 'Test suites heatmap',
                hintText: 'Commit rows × suite columns',
                emptyText: 'No test-suite rows found for the selected tree/branch/timeframe.'
            });
            setStatus(`Test nodes loaded: ${nodes.length}`, 'pass');
        }

        function renderAllTests(nodes) {
            const filtered = nodes.filter((node) => node.kind === 'test');
            const {rows, columns} = renderTestSuites(filtered, true);
            renderHeatGrid({
                rows,
                columns,
                titleText: 'All tests heatmap',
                hintText: 'Suite rows × commit columns',
                emptyText: 'No test rows found for the selected timeframe.'
            });
            setStatus(`Test nodes loaded: ${nodes.length}`, 'pass');
        }

        function updateFiltersFromMode(nodes) {
            state.currentNodes = nodes;
            if (state.tree && !collectTreeBranch(nodes).trees.includes(state.tree)) {
                state.tree = '';
                state.branch = '';
            }
            if (state.branch && state.tree &&
                !collectTreeBranch(nodes).branchMap[state.tree]?.includes(state.branch)) {
                state.branch = '';
            }
            if (state.mode === 'tests' && nodes.length === 0) {
                state.tree = '';
                state.branch = '';
            }
        }

        async function renderDashboard() {
            parseState();
            renderMenuBar();
            renderLegend();

            const viewTitle = document.getElementById('viewTitle');
            const viewHint = document.getElementById('viewHint');
            const content = document.getElementById('content');

            if (state.mode === 'home') {
                state.currentNodes = [];
                renderHome();
                setStatus('Ready', '');
                return;
            }

            setStatus('Loading data', 'pass');
            content.innerHTML = '<div class="empty"><span class="spinner"></span> Fetching nodes...</div>';

            try {
                const nodes = await fetchAllNodes(state.mode === 'builds' ? 'kbuild' : 'test');
                state.currentNodes = nodes;
                updateFiltersFromMode(nodes);
                renderMenuBar();
                if (state.mode === 'builds') {
                    viewTitle.textContent = 'Builds';
                    viewHint.textContent = `Showing ${state.tree || 'all trees'}${state.branch ? ` / ${state.branch}` : ''}`;
                    renderBuilds(nodes);
                }
                if (state.mode === 'testsuites') {
                    viewTitle.textContent = 'Test suites';
                    viewHint.textContent = `Showing ${state.tree || 'all trees'}${state.branch ? ` / ${state.branch}` : ''}`;
                    renderTestsuitesView(nodes);
                }
                if (state.mode === 'tests') {
                    viewTitle.textContent = 'All tests';
                    viewHint.textContent = `Showing ${state.timeframe} across ${state.tree || 'all trees'}`;
                    renderAllTests(nodes);
                }
            } catch (error) {
                setError(error.message || 'Failed to load data');
            }
        }

        window.addEventListener('popstate', renderDashboard);
        document.addEventListener('DOMContentLoaded', renderDashboard);
    </script>
</body>
</html>
